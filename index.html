<!DOCTYPE html>
<html>
<head>
  <script>
    function copyToClipboard(textbox) {
        textbox.select();
        document.execCommand("copy");
        alert("Copied the text: " + textbox.value);
      }
  </script>
</head>
<body>
    <div>
        <P><<h2>BFS</h2>
  <textarea id="textbox1" rows="25" cols="100">
graph = {
  '5' : ['3','7'],
  '3' : ['2', '4','5'],
  '7' : ['8'],
  '2' : [],
  '4' : ['8'],
  '8' : []
}
visited = [] 
queue = []
def bfs(visited, graph, node): 
  visited.append(node)
  queue.append(node)
  while queue:         
    m = queue.pop(0) 
    print (m,end=" ") 
    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)
print("Following is the Breadth-First Search")
bfs(visited, graph, '5')
  </textarea>
  <button onclick="copyToClipboard(document.getElementById('textbox1'))">Copy</button>
    <br>
  </div>
<!------------------------------------------------------ -->
  <div>
        <P><<h2>DFS</h2>
  <textarea id="textbox2" rows="25" cols="100">
graph = {
  '5' : ['3','7'],
  '3' : ['2', '4'],
  '7' : ['8'],
  '2' : [],
  '4' : ['8'],
  '8' : []
}
visited = [] 
def dfs(visited, graph, node):  
    if node not in visited:
        print (node)
        visited.append(node)
        for neighbour in graph[node]:
            dfs(visited, graph, neighbour)
print("Following is the Depth-First Search")
dfs(visited, graph, '5')
  </textarea>
  <button onclick="copyToClipboard(document.getElementById('textbox2'))">Copy</button>
    <br>
  </div>

  <!------------------------------------------------------ -->
  <div>
        <P><<h2> greedy BFS</h2>
  <textarea id="textbox3" rows="25" cols="100">
SuccList ={'A':[['B',3],['C',2]], 
           'B':[['A',5],['C',2],['D',2],['E',3]], 
           'C':[['A',5],['B',3],['F',2],['G',4]], 
           'D':[['H',1],['I',99]],
           'F': [['J',99]],
           'G':[['K',99],['L',3]]}
Start='A'
Goal='E'
Closed = list()
SUCCESS=True
FAILURE=False
State=FAILURE


def MOVEGEN(N):
	New_list=list()
	if N in SuccList.keys():
		New_list=SuccList[N]
	
	return New_list
	
def GOALTEST(N):
	if N == Goal:
		return True
	else:
		return False


def APPEND(L1,L2):
	New_list=list(L1)+list(L2)
	return New_list
	
def SORT(L):
	L.sort(key = lambda x: x[1]) 
	return L 
	
def BestFirstSearch():
	OPEN=[[Start,5]]
	CLOSED=list()
	global State
	global Closed
	while (len(OPEN) != 0) and (State != SUCCESS):
		print("------------")
		N= OPEN[0]
		print("N=",N)
		del OPEN[0] #delete the node we picked
		
		if GOALTEST(N[0])==True:
			State = SUCCESS
			CLOSED = APPEND(CLOSED,[N])
			print("CLOSED=",CLOSED)
		else:
			CLOSED = APPEND(CLOSED,[N])
			print("CLOSED=",CLOSED)
			CHILD = MOVEGEN(N[0])
			print("CHILD=",CHILD)
			for val in CLOSED:
				if val in CHILD:
					CHILD.remove(val)
			for val in OPEN:
				if val in CHILD:
					CHILD.remove(val)
			OPEN = APPEND(CHILD,OPEN) #append movegen elements to OPEN
			print("Unsorted OPEN=",OPEN)
			SORT(OPEN)
			print("Sorted OPEN=",OPEN)
			
	Closed=CLOSED
	return State
	
#Driver Code
result=BestFirstSearch() #call search algorithm
print(Closed,result)
  </textarea>
  <button onclick="copyToClipboard(document.getElementById('textbox3'))">Copy</button>
    <br>
  </div>

<!------------------------------------------------------ -->
  <div>
        <P><<h2>A star</h2>
  <textarea id="textbox4" rows="25" cols="100">
from queue import heappop,heappush
from math import inf
class Graph:
    def __init__(self,directed=True):
        self.edges={}
        self.huristics={}
        self.directed=directed
    def add_edge(self,node1,node2,cost=1,__reversed=False):
        try:neighbors=self.edges[node1]
        except KeyError:neighbors={}
        neighbors[node2]=cost
        self.edges[node1]=neighbors
        if not self.directed and not __reversed:self.add_edge(node2,node1,cost,True)
    def set_huristics(self,huristics={}):
        self.huristics=huristics
    def neighbors(self,node):
        try:return self.edges[node]
        except KeyError:return[]
    def cost(self,node1,node2):
        try:return self.edges[node1][node2]
        except:return inf
    def a_star_search(self,start,goal):
        found,fringe,visited,came_from,cost_so_far=False,[(self.huristics[start],start)],set([start]),{start:None},{start:0}
        print('{:11s}|{}'.format('Expand Node','Fringe'))
        print('---------------')
        print('{:11s}|{}'.format('-',str(fringe[0])))
        while not found and len(fringe):
            _,current=heappop(fringe)
            print('{:11s}'.format(current),end='|')
            if current==goal:found=True;break
            for node in self.neighbors(current):
                new_cost=cost_so_far[current]+self.cost(current,node)
                if node not in visited or cost_so_far[node]>new_cost:
                    visited.add(node);came_from[node]=current;cost_so_far[node]=new_cost
                    heappush(fringe,(new_cost+self.huristics[node],node))
            print(','.join([str(n) for n in fringe]))
        if found:print();return came_from,cost_so_far[goal]
        else:print('No path from {} to {}'.format(start,goal));return None,inf
    @staticmethod
    def print_path(came_from,goal):
        parent=came_from[goal]
        if parent:
            Graph.print_path(came_from,parent)
        else:print(goal,end='');return
        print('=>',goal,end='')
    def __str__(self):
        return str(self.edges)
graph=Graph(directed=True)
graph.add_edge('A','B',4)
graph.add_edge('A','C',1)
graph.add_edge('B','D',3)
graph.add_edge('B','E',8)
graph.add_edge('C','C',0)
graph.add_edge('C','D',7)
graph.add_edge('C','F',6)
graph.add_edge('D','C',2)
graph.add_edge('D','E',4)
graph.add_edge('E','G',2)
graph.add_edge('F','G',8)
graph.set_huristics({'A':8,'B':8,'C':6,'D':5,'E':1,'F':4,'G':0})
start,goal='A','G'
traced_path,cost=graph.a_star_search(start,goal)
if(traced_path):print('Path:',end='');Graph.print_path(traced_path,goal);
print('\nCost:',cost)
  </textarea>
  <button onclick="copyToClipboard(document.getElementById('textbox4'))">Copy</button>
    <br>
  </div>
</body>
</html>
